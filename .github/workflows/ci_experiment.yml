name: CI Experiment

permissions: read-all
#permissions:
#  contents: read

concurrency:
  group: ci-experiment-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - staging
      - trying
  pull_request:
    branches: [master]
    paths:
      - "**"
      - "!/*.md"
      - "!/**.md"
      - "!/rfc/**"
  workflow_dispatch:
    inputs:
      verbose:
        description: "Set --verbose to get verbose build output"
        required: false
        default: ""

      rust-channel:
        description: "Version of Rust release channel to use in builds"
        required: false
        type: choice
        options:
          - stable
          - beta
          - nightly
        default: stable
      build-name:
        description: "Name to add to VERSION. (git hash will be appended to build-name automatically)"
        required: true
        type: string
      release-after-build:
        description: "Release artifacts to package manager at end (w/o GH Release)"
        type: boolean
        default: false
      build-binary:
        description: 'Choose which binary to build'
        required: true
        type: choice
        options:
          - fluvio 
          - fluvio-run 
          - fluvio-test 
          - fluvio-channel
          - smdk
          - fbm
          - cdk
      binary-arch:
        description: "Rust target binary to build"
        required: true
        type: choice
        options:
          - x86_64-unknown-linux-musl
          - aarch64-unknown-linux-musl
          - arm-unknown-linux-gnueabihf
          - armv7-unknown-linux-gnueabihf
          - x86_64-apple-darwin
          - aarch64-apple-darwin
          - x86_64-pc-windows-gnu
      docker-image:
        description: "Build a docker image"
        required: false
        type: choice
        options:
          - x86_64-unknown-linux-musl
          - aarch64-unknown-linux-musl
      run-ci-tests:
        description: "Opt-in to run the CI tests"
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  VERBOSE: ${{ github.events.input.verbose }}
  K3D_VERSION: v5.4.9
  BATS_VERSION: 1.9.0
  MINIKUBE_VERSION: v1.30.1
  K8_VERSION: v1.26.3
  TLS_ARGS: --tls --domain fluvio.local --server-key ./tls/certs/server.key --server-cert ./tls/certs/server.crt --ca-cert ./tls/certs/ca.crt --client-cert ./tls/certs/client-root.crt --client-key ./tls/certs/client-root.key
  AUTH_FILE: crates/fluvio-sc/test-data/auth_config/policy.json
  X509_SCOPE_FILE: crates/fluvio-sc/test-data/auth_config/scopes.json
  FLV_CLUSTER_PROVISION_TIMEOUT: 600
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}


# TODO: 
  # - Opt into the testing
  # - Include workflow for release that accomodates a private build (probably don't use GH Release - will require rebuild every time)
  # - Update the VERSION before building to denote the experimental nature of the release
  # - Add selection for rust targets to opt-in
  # - Add selection for binaries
  # - Add selection for docker images + arch

jobs:
  # this job set up dynamic configuration shared among jobs
  config:
    name: Set up Config
    runs-on: ubuntu-latest
    env:
      ENABLE_CHECK: true
      TEST_RUNS: "[r1]" # default runs
    outputs:
      check: ${{ steps.check.outputs.check }}
      runs: ${{ steps.runs.outputs.runs }}
    steps:
      - id: check
        run: echo "::set-output name=check::${{ env.ENABLE_CHECK }}"
      #- name: Set Staging runs
      ##  if: github.event_name == 'push' && github.ref == 'refs/heads/staging'
      #  run: echo "TEST_RUNS='[r1,r2,r3,r4,r5]'" | tee -a $GITHUB_ENV

      - uses: cloudposse/github-action-matrix-outputs-write@main
        id: out
        with:
          matrix-step-name: ${{ github.job }}
          matrix-key: "experiment" 
          outputs: |-
            build-name: ${{ inputs.build-name }}
            rust-channel: ${{ inputs.rust-channel }}
            release-after-build: ${{ inputs.release-after-build }}
            binary-arch: ${{ inputs.binary-arch }}
            docker-image: ${{ inputs.docker-image }}
            run-ci-tests: ${{ inputs.run-ci-tests }}

  read:
    runs-on: ubuntu-latest
    needs: [config]
    steps:
      - uses: cloudposse/github-action-matrix-outputs-read@main
        id: read
        with:
          matrix-step-name: config 
  
    outputs:
      result: "${{ steps.read.outputs.result }}"

  # NOTE: This is expected to fail to build any non-linux binaries
  build_binary:
    needs: [read]
    runs-on: ubuntu-latest
    env:
      OS: ubuntu-latest
      BUILD_BINARY: ${{ fromJson(needs.read.outputs.result).build-binary }}
      BUILD_NAME: ${{ fromJson(needs.read.outputs.result).build-name }}
      RUST_BACKTRACE: full
      RUSTV: ${{ fromJson(needs.read.outputs.result).rust-channel }}
      TARGET: ${{ fromJson(needs.read.outputs.result).binary-arch }}
      RUST_BIN_DIR: target/${{ fromJson(needs.read.outputs.result).binary-arch }}/release
      RELEASE_NAME: release
      RELEASE: true
    steps:
      - uses: actions/checkout@v3
      - name: Add experimental build name to VERSION
        run: echo "-${{ env.BUILD_NAME }}-${{ github.sha }}" >> VERSION
      - name: Print env
        run: |
          echo "BUILD_NAME = ${{ env.BUILD_NAME }}"
          echo "RUST_BIN_DIR = ${{ env.RUST_BIN_DIR }}"
      - name: Install Rust ${{ env.RUSTV }}
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ env.TARGET }}
          profile: minimal
      - name: Install LLVM and Clang
        uses: KyleMayes/install-llvm-action@v1
        with:
          version: "14.0"
      - name: Install zig
        run: ./actions/zig-install.sh ${{ env.OS }}
      - uses: Swatinem/rust-cache@v2
        timeout-minutes: 10
        with:
          key: ${{ env.BUILD_NAME }}-${{ env.RUST_BIN_DIR }}-${{ env.BUILD_BINARY }}

      - name: Build fluvio
        if: env.BUILD_BINARY == 'fluvio'
        run: make build-cli

      - name: Build fluvio-run
        if: env.BUILD_BINARY == 'fluvio-run' || ${{ fromJson(needs.read.outputs.result).docker-image }}
        run: make build-cluster

      - name: Build fluvio-test
        if: env.BUILD_BINARY == 'fluvio-test'
        run: make build-test

      - name: Build fluvio-channel
        if: env.BUILD_BINARY == 'fluvio-channel'
        run: make build-channel

      - name: Build smdk
        if: env.BUILD_BINARY == 'smdk'
        run: make build-smdk

      - name: Build cdk
        if: env.BUILD_BINARY == 'cdk'
        run: make build-cdk

      - name: Build fbm
        if: env.BUILD_BINARY == 'fbm'
        run: make build-fbm

      # Upload artifacts
      - name: Upload artifact - ${{ env.BUILD_BINARY }}
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.BUILD_BINARY }}-${{ env.TARGET }}
          path: ${{ env.RUST_BIN_DIR }}/${{ env.BUILD_BINARY }}
          retention-days: 1
  
  # TODO: Deal with this after binaries 
  #build_image:
  #  name: Build Fluvio Docker image
  #  needs: [read,build_binary]
  #  runs-on: ${{ matrix.os }}
  #  strategy:
  #    matrix:
  #      os: [ubuntu-latest]
  #      #rust-target:
  #      #  - x86_64-unknown-linux-musl
  #      #  - aarch64-unknown-linux-musl
  #      rust: [stable]
  #  env:
  #    OS: ubuntu-latest
  #    BUILD_BINARY: ${{ fromJson(needs.read.outputs.result).build-binary }}
  #    BUILD_NAME: ${{ fromJson(needs.read.outputs.result).build-name }}
  #    RUST_BACKTRACE: full
  #    RUSTV: ${{ fromJson(needs.read.outputs.result).rust-channel }}
  #    TARGET: ${{ fromJson(needs.read.outputs.result).binary-arch }}
  #  steps:
  #    # Needed for k8-util/docker/build.sh
  #    - uses: actions/checkout@v3

  #    # Download artifacts
  #    - name: Download fluvio-run
  #      uses: actions/download-artifact@v3
  #      with:
  #        name: fluvio-run-${{ env.TARGET }}
  #        path: .

  #    - name: Print fluvio-run path
  #      run: pwd && ls -la . && chmod +x ./fluvio-run && ./fluvio-run -h || true

  #    # Build and upload docker image
  #    - name: Build Docker image
  #      run: k8-util/docker/build.sh ${{ env.TARGET }} ${{ github.sha }} "$(pwd)/fluvio-run"
  #    - name: Export Docker Image to tarball
  #      run: docker image save infinyon/fluvio:${{ github.sha }}-${{ env.TARGET }} --output /tmp/infinyon-fluvio-${{ env.TARGET }}.tar
  #    - name: Upload tarball as artifact
  #      uses: actions/upload-artifact@v3
  #      with:
  #        name: infinyon-fluvio-${{ env.TARGET }}.tar
  #        path: /tmp/infinyon-fluvio-${{ env.TARGET }}.tar
  #        retention-days: 1

  # Publish experimental build artifacts to packages.fluvio.io 
  release_experimental_binary:
    name: Release Fluvio CLI package
    needs: [build_binary]
    runs-on: ubuntu-latest
    env:
      BUILD_BINARY: ${{ fromJson(needs.read.outputs.result).build-binary }}
      TARGET: ${{ fromJson(needs.read.outputs.result).binary-arch }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #VERSION: ${{ needs.setup_job.outputs.VERSION }}
      #INSTALLER_URL: ${{ needs.setup_job.outputs.INSTALLER_URL }}
      #BPKG_TOKEN: ${{ secrets.BPKG_TOKEN }}
    steps:
      - uses: actions/checkout@v3
      # Check that this release does not already exist by trying to download it
      - name: Attempt to install Fluvio CLI
        id: check_fluvio
        continue-on-error: true
        env:
          CHANNEL_TAG: stable 
        run: make curl-install-fluvio

      # If this release does not already exist (i.e. check_fluvio failed), continue
      - name: Install fluvio-package
        env:
          CHANNEL_TAG: stable # We want to ensure we install the stable version of CLI
        run: |
          make curl-install-fluvio
          make install-fluvio-package

      # Get binary artifacts
      - name: Download artifact - ${{ env.BUILD_BINARY }}-${{ env.TARGET }}
        uses: actions/download-artifact@v3
        with:
          name: ${{ env.BUILD_BINARY }}-${{ env.TARGET }}
          path: . 
      
      - name: Publish artifacts
        if: ${{ steps.check_fluvio.outcome == 'failure' }}
        env:
          FLUVIO_BIN: ~/.fluvio/bin/fluvio
        run: |
          make publish-artifacts-stable
          ${{ env.FLUVIO_BIN }} package publish --package=${{ env.BUILD_BINARY }} --version=${{ env.BUILD_BINARY }}-${{ github.sha }} --target=${{ env.TARGET }} ./${{ env.BUILD_BINARY }}-${{ env.TARGET }}

      - name: Slack Notification
        uses: 8398a7/action-slack@v3
        if: ${{ !success() }}
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow,job
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          #MATRIX_CONTEXT: ${{ toJson(matrix) }}

  # Job that follows the success of all required jobs in this workflow.
  # Used by Bors to detect that all required jobs have completed successfully
  done:
    name: Done
    if: github.event_name == 'push' && github.ref == 'refs/heads/staging'
    needs: [release_experimental_binary]
    runs-on: ubuntu-latest
    steps:
      - name: Done
        run: echo "Done!"
